// Code generated by counterfeiter. DO NOT EDIT.
package batchfakes

import (
	"sync"

	"github.com/batchcorp/terraform-provider-batchsh/batch"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
)

type FakeIBatchAPI struct {
	CreateCollectionStub        func(*batch.CreateCollectionRequest) (*batch.CreateCollectionResponse, diag.Diagnostics)
	createCollectionMutex       sync.RWMutex
	createCollectionArgsForCall []struct {
		arg1 *batch.CreateCollectionRequest
	}
	createCollectionReturns struct {
		result1 *batch.CreateCollectionResponse
		result2 diag.Diagnostics
	}
	createCollectionReturnsOnCall map[int]struct {
		result1 *batch.CreateCollectionResponse
		result2 diag.Diagnostics
	}
	CreateTeamMemberStub        func(*batch.CreateTeamMemberRequest) (*batch.CreateTeamMemberResponse, diag.Diagnostics)
	createTeamMemberMutex       sync.RWMutex
	createTeamMemberArgsForCall []struct {
		arg1 *batch.CreateTeamMemberRequest
	}
	createTeamMemberReturns struct {
		result1 *batch.CreateTeamMemberResponse
		result2 diag.Diagnostics
	}
	createTeamMemberReturnsOnCall map[int]struct {
		result1 *batch.CreateTeamMemberResponse
		result2 diag.Diagnostics
	}
	DeleteCollectionStub        func(string) (*batch.UpdateCollectionResponse, diag.Diagnostics)
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		arg1 string
	}
	deleteCollectionReturns struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}
	DeleteTeamMemberStub        func(string) diag.Diagnostics
	deleteTeamMemberMutex       sync.RWMutex
	deleteTeamMemberArgsForCall []struct {
		arg1 string
	}
	deleteTeamMemberReturns struct {
		result1 diag.Diagnostics
	}
	deleteTeamMemberReturnsOnCall map[int]struct {
		result1 diag.Diagnostics
	}
	GetCollectionStub        func(string) (*batch.ReadCollectionResponse, diag.Diagnostics)
	getCollectionMutex       sync.RWMutex
	getCollectionArgsForCall []struct {
		arg1 string
	}
	getCollectionReturns struct {
		result1 *batch.ReadCollectionResponse
		result2 diag.Diagnostics
	}
	getCollectionReturnsOnCall map[int]struct {
		result1 *batch.ReadCollectionResponse
		result2 diag.Diagnostics
	}
	GetDataLakeStub        func([]*batch.Filter) (map[string]interface{}, diag.Diagnostics)
	getDataLakeMutex       sync.RWMutex
	getDataLakeArgsForCall []struct {
		arg1 []*batch.Filter
	}
	getDataLakeReturns struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}
	getDataLakeReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}
	GetSchemaStub        func([]*batch.Filter) (map[string]interface{}, diag.Diagnostics)
	getSchemaMutex       sync.RWMutex
	getSchemaArgsForCall []struct {
		arg1 []*batch.Filter
	}
	getSchemaReturns struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}
	getSchemaReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}
	GetTeamMemberStub        func(string) (*batch.ReadTeamMemberResponse, diag.Diagnostics)
	getTeamMemberMutex       sync.RWMutex
	getTeamMemberArgsForCall []struct {
		arg1 string
	}
	getTeamMemberReturns struct {
		result1 *batch.ReadTeamMemberResponse
		result2 diag.Diagnostics
	}
	getTeamMemberReturnsOnCall map[int]struct {
		result1 *batch.ReadTeamMemberResponse
		result2 diag.Diagnostics
	}
	UpdateCollectionStub        func(string, *batch.UpdateCollectionRequest) (*batch.UpdateCollectionResponse, diag.Diagnostics)
	updateCollectionMutex       sync.RWMutex
	updateCollectionArgsForCall []struct {
		arg1 string
		arg2 *batch.UpdateCollectionRequest
	}
	updateCollectionReturns struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}
	updateCollectionReturnsOnCall map[int]struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}
	UpdateTeamMemberStub        func(string, *batch.UpdateTeamMemberRequest) (*batch.UpdateTeamMemberResponse, diag.Diagnostics)
	updateTeamMemberMutex       sync.RWMutex
	updateTeamMemberArgsForCall []struct {
		arg1 string
		arg2 *batch.UpdateTeamMemberRequest
	}
	updateTeamMemberReturns struct {
		result1 *batch.UpdateTeamMemberResponse
		result2 diag.Diagnostics
	}
	updateTeamMemberReturnsOnCall map[int]struct {
		result1 *batch.UpdateTeamMemberResponse
		result2 diag.Diagnostics
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIBatchAPI) CreateCollection(arg1 *batch.CreateCollectionRequest) (*batch.CreateCollectionResponse, diag.Diagnostics) {
	fake.createCollectionMutex.Lock()
	ret, specificReturn := fake.createCollectionReturnsOnCall[len(fake.createCollectionArgsForCall)]
	fake.createCollectionArgsForCall = append(fake.createCollectionArgsForCall, struct {
		arg1 *batch.CreateCollectionRequest
	}{arg1})
	stub := fake.CreateCollectionStub
	fakeReturns := fake.createCollectionReturns
	fake.recordInvocation("CreateCollection", []interface{}{arg1})
	fake.createCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) CreateCollectionCallCount() int {
	fake.createCollectionMutex.RLock()
	defer fake.createCollectionMutex.RUnlock()
	return len(fake.createCollectionArgsForCall)
}

func (fake *FakeIBatchAPI) CreateCollectionCalls(stub func(*batch.CreateCollectionRequest) (*batch.CreateCollectionResponse, diag.Diagnostics)) {
	fake.createCollectionMutex.Lock()
	defer fake.createCollectionMutex.Unlock()
	fake.CreateCollectionStub = stub
}

func (fake *FakeIBatchAPI) CreateCollectionArgsForCall(i int) *batch.CreateCollectionRequest {
	fake.createCollectionMutex.RLock()
	defer fake.createCollectionMutex.RUnlock()
	argsForCall := fake.createCollectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) CreateCollectionReturns(result1 *batch.CreateCollectionResponse, result2 diag.Diagnostics) {
	fake.createCollectionMutex.Lock()
	defer fake.createCollectionMutex.Unlock()
	fake.CreateCollectionStub = nil
	fake.createCollectionReturns = struct {
		result1 *batch.CreateCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) CreateCollectionReturnsOnCall(i int, result1 *batch.CreateCollectionResponse, result2 diag.Diagnostics) {
	fake.createCollectionMutex.Lock()
	defer fake.createCollectionMutex.Unlock()
	fake.CreateCollectionStub = nil
	if fake.createCollectionReturnsOnCall == nil {
		fake.createCollectionReturnsOnCall = make(map[int]struct {
			result1 *batch.CreateCollectionResponse
			result2 diag.Diagnostics
		})
	}
	fake.createCollectionReturnsOnCall[i] = struct {
		result1 *batch.CreateCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) CreateTeamMember(arg1 *batch.CreateTeamMemberRequest) (*batch.CreateTeamMemberResponse, diag.Diagnostics) {
	fake.createTeamMemberMutex.Lock()
	ret, specificReturn := fake.createTeamMemberReturnsOnCall[len(fake.createTeamMemberArgsForCall)]
	fake.createTeamMemberArgsForCall = append(fake.createTeamMemberArgsForCall, struct {
		arg1 *batch.CreateTeamMemberRequest
	}{arg1})
	stub := fake.CreateTeamMemberStub
	fakeReturns := fake.createTeamMemberReturns
	fake.recordInvocation("CreateTeamMember", []interface{}{arg1})
	fake.createTeamMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) CreateTeamMemberCallCount() int {
	fake.createTeamMemberMutex.RLock()
	defer fake.createTeamMemberMutex.RUnlock()
	return len(fake.createTeamMemberArgsForCall)
}

func (fake *FakeIBatchAPI) CreateTeamMemberCalls(stub func(*batch.CreateTeamMemberRequest) (*batch.CreateTeamMemberResponse, diag.Diagnostics)) {
	fake.createTeamMemberMutex.Lock()
	defer fake.createTeamMemberMutex.Unlock()
	fake.CreateTeamMemberStub = stub
}

func (fake *FakeIBatchAPI) CreateTeamMemberArgsForCall(i int) *batch.CreateTeamMemberRequest {
	fake.createTeamMemberMutex.RLock()
	defer fake.createTeamMemberMutex.RUnlock()
	argsForCall := fake.createTeamMemberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) CreateTeamMemberReturns(result1 *batch.CreateTeamMemberResponse, result2 diag.Diagnostics) {
	fake.createTeamMemberMutex.Lock()
	defer fake.createTeamMemberMutex.Unlock()
	fake.CreateTeamMemberStub = nil
	fake.createTeamMemberReturns = struct {
		result1 *batch.CreateTeamMemberResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) CreateTeamMemberReturnsOnCall(i int, result1 *batch.CreateTeamMemberResponse, result2 diag.Diagnostics) {
	fake.createTeamMemberMutex.Lock()
	defer fake.createTeamMemberMutex.Unlock()
	fake.CreateTeamMemberStub = nil
	if fake.createTeamMemberReturnsOnCall == nil {
		fake.createTeamMemberReturnsOnCall = make(map[int]struct {
			result1 *batch.CreateTeamMemberResponse
			result2 diag.Diagnostics
		})
	}
	fake.createTeamMemberReturnsOnCall[i] = struct {
		result1 *batch.CreateTeamMemberResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) DeleteCollection(arg1 string) (*batch.UpdateCollectionResponse, diag.Diagnostics) {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteCollectionStub
	fakeReturns := fake.deleteCollectionReturns
	fake.recordInvocation("DeleteCollection", []interface{}{arg1})
	fake.deleteCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakeIBatchAPI) DeleteCollectionCalls(stub func(string) (*batch.UpdateCollectionResponse, diag.Diagnostics)) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = stub
}

func (fake *FakeIBatchAPI) DeleteCollectionArgsForCall(i int) string {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	argsForCall := fake.deleteCollectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) DeleteCollectionReturns(result1 *batch.UpdateCollectionResponse, result2 diag.Diagnostics) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) DeleteCollectionReturnsOnCall(i int, result1 *batch.UpdateCollectionResponse, result2 diag.Diagnostics) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 *batch.UpdateCollectionResponse
			result2 diag.Diagnostics
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) DeleteTeamMember(arg1 string) diag.Diagnostics {
	fake.deleteTeamMemberMutex.Lock()
	ret, specificReturn := fake.deleteTeamMemberReturnsOnCall[len(fake.deleteTeamMemberArgsForCall)]
	fake.deleteTeamMemberArgsForCall = append(fake.deleteTeamMemberArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteTeamMemberStub
	fakeReturns := fake.deleteTeamMemberReturns
	fake.recordInvocation("DeleteTeamMember", []interface{}{arg1})
	fake.deleteTeamMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIBatchAPI) DeleteTeamMemberCallCount() int {
	fake.deleteTeamMemberMutex.RLock()
	defer fake.deleteTeamMemberMutex.RUnlock()
	return len(fake.deleteTeamMemberArgsForCall)
}

func (fake *FakeIBatchAPI) DeleteTeamMemberCalls(stub func(string) diag.Diagnostics) {
	fake.deleteTeamMemberMutex.Lock()
	defer fake.deleteTeamMemberMutex.Unlock()
	fake.DeleteTeamMemberStub = stub
}

func (fake *FakeIBatchAPI) DeleteTeamMemberArgsForCall(i int) string {
	fake.deleteTeamMemberMutex.RLock()
	defer fake.deleteTeamMemberMutex.RUnlock()
	argsForCall := fake.deleteTeamMemberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) DeleteTeamMemberReturns(result1 diag.Diagnostics) {
	fake.deleteTeamMemberMutex.Lock()
	defer fake.deleteTeamMemberMutex.Unlock()
	fake.DeleteTeamMemberStub = nil
	fake.deleteTeamMemberReturns = struct {
		result1 diag.Diagnostics
	}{result1}
}

func (fake *FakeIBatchAPI) DeleteTeamMemberReturnsOnCall(i int, result1 diag.Diagnostics) {
	fake.deleteTeamMemberMutex.Lock()
	defer fake.deleteTeamMemberMutex.Unlock()
	fake.DeleteTeamMemberStub = nil
	if fake.deleteTeamMemberReturnsOnCall == nil {
		fake.deleteTeamMemberReturnsOnCall = make(map[int]struct {
			result1 diag.Diagnostics
		})
	}
	fake.deleteTeamMemberReturnsOnCall[i] = struct {
		result1 diag.Diagnostics
	}{result1}
}

func (fake *FakeIBatchAPI) GetCollection(arg1 string) (*batch.ReadCollectionResponse, diag.Diagnostics) {
	fake.getCollectionMutex.Lock()
	ret, specificReturn := fake.getCollectionReturnsOnCall[len(fake.getCollectionArgsForCall)]
	fake.getCollectionArgsForCall = append(fake.getCollectionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetCollectionStub
	fakeReturns := fake.getCollectionReturns
	fake.recordInvocation("GetCollection", []interface{}{arg1})
	fake.getCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) GetCollectionCallCount() int {
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	return len(fake.getCollectionArgsForCall)
}

func (fake *FakeIBatchAPI) GetCollectionCalls(stub func(string) (*batch.ReadCollectionResponse, diag.Diagnostics)) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = stub
}

func (fake *FakeIBatchAPI) GetCollectionArgsForCall(i int) string {
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	argsForCall := fake.getCollectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) GetCollectionReturns(result1 *batch.ReadCollectionResponse, result2 diag.Diagnostics) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = nil
	fake.getCollectionReturns = struct {
		result1 *batch.ReadCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) GetCollectionReturnsOnCall(i int, result1 *batch.ReadCollectionResponse, result2 diag.Diagnostics) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = nil
	if fake.getCollectionReturnsOnCall == nil {
		fake.getCollectionReturnsOnCall = make(map[int]struct {
			result1 *batch.ReadCollectionResponse
			result2 diag.Diagnostics
		})
	}
	fake.getCollectionReturnsOnCall[i] = struct {
		result1 *batch.ReadCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) GetDataLake(arg1 []*batch.Filter) (map[string]interface{}, diag.Diagnostics) {
	var arg1Copy []*batch.Filter
	if arg1 != nil {
		arg1Copy = make([]*batch.Filter, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getDataLakeMutex.Lock()
	ret, specificReturn := fake.getDataLakeReturnsOnCall[len(fake.getDataLakeArgsForCall)]
	fake.getDataLakeArgsForCall = append(fake.getDataLakeArgsForCall, struct {
		arg1 []*batch.Filter
	}{arg1Copy})
	stub := fake.GetDataLakeStub
	fakeReturns := fake.getDataLakeReturns
	fake.recordInvocation("GetDataLake", []interface{}{arg1Copy})
	fake.getDataLakeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) GetDataLakeCallCount() int {
	fake.getDataLakeMutex.RLock()
	defer fake.getDataLakeMutex.RUnlock()
	return len(fake.getDataLakeArgsForCall)
}

func (fake *FakeIBatchAPI) GetDataLakeCalls(stub func([]*batch.Filter) (map[string]interface{}, diag.Diagnostics)) {
	fake.getDataLakeMutex.Lock()
	defer fake.getDataLakeMutex.Unlock()
	fake.GetDataLakeStub = stub
}

func (fake *FakeIBatchAPI) GetDataLakeArgsForCall(i int) []*batch.Filter {
	fake.getDataLakeMutex.RLock()
	defer fake.getDataLakeMutex.RUnlock()
	argsForCall := fake.getDataLakeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) GetDataLakeReturns(result1 map[string]interface{}, result2 diag.Diagnostics) {
	fake.getDataLakeMutex.Lock()
	defer fake.getDataLakeMutex.Unlock()
	fake.GetDataLakeStub = nil
	fake.getDataLakeReturns = struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) GetDataLakeReturnsOnCall(i int, result1 map[string]interface{}, result2 diag.Diagnostics) {
	fake.getDataLakeMutex.Lock()
	defer fake.getDataLakeMutex.Unlock()
	fake.GetDataLakeStub = nil
	if fake.getDataLakeReturnsOnCall == nil {
		fake.getDataLakeReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 diag.Diagnostics
		})
	}
	fake.getDataLakeReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) GetSchema(arg1 []*batch.Filter) (map[string]interface{}, diag.Diagnostics) {
	var arg1Copy []*batch.Filter
	if arg1 != nil {
		arg1Copy = make([]*batch.Filter, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getSchemaMutex.Lock()
	ret, specificReturn := fake.getSchemaReturnsOnCall[len(fake.getSchemaArgsForCall)]
	fake.getSchemaArgsForCall = append(fake.getSchemaArgsForCall, struct {
		arg1 []*batch.Filter
	}{arg1Copy})
	stub := fake.GetSchemaStub
	fakeReturns := fake.getSchemaReturns
	fake.recordInvocation("GetSchema", []interface{}{arg1Copy})
	fake.getSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) GetSchemaCallCount() int {
	fake.getSchemaMutex.RLock()
	defer fake.getSchemaMutex.RUnlock()
	return len(fake.getSchemaArgsForCall)
}

func (fake *FakeIBatchAPI) GetSchemaCalls(stub func([]*batch.Filter) (map[string]interface{}, diag.Diagnostics)) {
	fake.getSchemaMutex.Lock()
	defer fake.getSchemaMutex.Unlock()
	fake.GetSchemaStub = stub
}

func (fake *FakeIBatchAPI) GetSchemaArgsForCall(i int) []*batch.Filter {
	fake.getSchemaMutex.RLock()
	defer fake.getSchemaMutex.RUnlock()
	argsForCall := fake.getSchemaArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) GetSchemaReturns(result1 map[string]interface{}, result2 diag.Diagnostics) {
	fake.getSchemaMutex.Lock()
	defer fake.getSchemaMutex.Unlock()
	fake.GetSchemaStub = nil
	fake.getSchemaReturns = struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) GetSchemaReturnsOnCall(i int, result1 map[string]interface{}, result2 diag.Diagnostics) {
	fake.getSchemaMutex.Lock()
	defer fake.getSchemaMutex.Unlock()
	fake.GetSchemaStub = nil
	if fake.getSchemaReturnsOnCall == nil {
		fake.getSchemaReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 diag.Diagnostics
		})
	}
	fake.getSchemaReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) GetTeamMember(arg1 string) (*batch.ReadTeamMemberResponse, diag.Diagnostics) {
	fake.getTeamMemberMutex.Lock()
	ret, specificReturn := fake.getTeamMemberReturnsOnCall[len(fake.getTeamMemberArgsForCall)]
	fake.getTeamMemberArgsForCall = append(fake.getTeamMemberArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTeamMemberStub
	fakeReturns := fake.getTeamMemberReturns
	fake.recordInvocation("GetTeamMember", []interface{}{arg1})
	fake.getTeamMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) GetTeamMemberCallCount() int {
	fake.getTeamMemberMutex.RLock()
	defer fake.getTeamMemberMutex.RUnlock()
	return len(fake.getTeamMemberArgsForCall)
}

func (fake *FakeIBatchAPI) GetTeamMemberCalls(stub func(string) (*batch.ReadTeamMemberResponse, diag.Diagnostics)) {
	fake.getTeamMemberMutex.Lock()
	defer fake.getTeamMemberMutex.Unlock()
	fake.GetTeamMemberStub = stub
}

func (fake *FakeIBatchAPI) GetTeamMemberArgsForCall(i int) string {
	fake.getTeamMemberMutex.RLock()
	defer fake.getTeamMemberMutex.RUnlock()
	argsForCall := fake.getTeamMemberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIBatchAPI) GetTeamMemberReturns(result1 *batch.ReadTeamMemberResponse, result2 diag.Diagnostics) {
	fake.getTeamMemberMutex.Lock()
	defer fake.getTeamMemberMutex.Unlock()
	fake.GetTeamMemberStub = nil
	fake.getTeamMemberReturns = struct {
		result1 *batch.ReadTeamMemberResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) GetTeamMemberReturnsOnCall(i int, result1 *batch.ReadTeamMemberResponse, result2 diag.Diagnostics) {
	fake.getTeamMemberMutex.Lock()
	defer fake.getTeamMemberMutex.Unlock()
	fake.GetTeamMemberStub = nil
	if fake.getTeamMemberReturnsOnCall == nil {
		fake.getTeamMemberReturnsOnCall = make(map[int]struct {
			result1 *batch.ReadTeamMemberResponse
			result2 diag.Diagnostics
		})
	}
	fake.getTeamMemberReturnsOnCall[i] = struct {
		result1 *batch.ReadTeamMemberResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) UpdateCollection(arg1 string, arg2 *batch.UpdateCollectionRequest) (*batch.UpdateCollectionResponse, diag.Diagnostics) {
	fake.updateCollectionMutex.Lock()
	ret, specificReturn := fake.updateCollectionReturnsOnCall[len(fake.updateCollectionArgsForCall)]
	fake.updateCollectionArgsForCall = append(fake.updateCollectionArgsForCall, struct {
		arg1 string
		arg2 *batch.UpdateCollectionRequest
	}{arg1, arg2})
	stub := fake.UpdateCollectionStub
	fakeReturns := fake.updateCollectionReturns
	fake.recordInvocation("UpdateCollection", []interface{}{arg1, arg2})
	fake.updateCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) UpdateCollectionCallCount() int {
	fake.updateCollectionMutex.RLock()
	defer fake.updateCollectionMutex.RUnlock()
	return len(fake.updateCollectionArgsForCall)
}

func (fake *FakeIBatchAPI) UpdateCollectionCalls(stub func(string, *batch.UpdateCollectionRequest) (*batch.UpdateCollectionResponse, diag.Diagnostics)) {
	fake.updateCollectionMutex.Lock()
	defer fake.updateCollectionMutex.Unlock()
	fake.UpdateCollectionStub = stub
}

func (fake *FakeIBatchAPI) UpdateCollectionArgsForCall(i int) (string, *batch.UpdateCollectionRequest) {
	fake.updateCollectionMutex.RLock()
	defer fake.updateCollectionMutex.RUnlock()
	argsForCall := fake.updateCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIBatchAPI) UpdateCollectionReturns(result1 *batch.UpdateCollectionResponse, result2 diag.Diagnostics) {
	fake.updateCollectionMutex.Lock()
	defer fake.updateCollectionMutex.Unlock()
	fake.UpdateCollectionStub = nil
	fake.updateCollectionReturns = struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) UpdateCollectionReturnsOnCall(i int, result1 *batch.UpdateCollectionResponse, result2 diag.Diagnostics) {
	fake.updateCollectionMutex.Lock()
	defer fake.updateCollectionMutex.Unlock()
	fake.UpdateCollectionStub = nil
	if fake.updateCollectionReturnsOnCall == nil {
		fake.updateCollectionReturnsOnCall = make(map[int]struct {
			result1 *batch.UpdateCollectionResponse
			result2 diag.Diagnostics
		})
	}
	fake.updateCollectionReturnsOnCall[i] = struct {
		result1 *batch.UpdateCollectionResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) UpdateTeamMember(arg1 string, arg2 *batch.UpdateTeamMemberRequest) (*batch.UpdateTeamMemberResponse, diag.Diagnostics) {
	fake.updateTeamMemberMutex.Lock()
	ret, specificReturn := fake.updateTeamMemberReturnsOnCall[len(fake.updateTeamMemberArgsForCall)]
	fake.updateTeamMemberArgsForCall = append(fake.updateTeamMemberArgsForCall, struct {
		arg1 string
		arg2 *batch.UpdateTeamMemberRequest
	}{arg1, arg2})
	stub := fake.UpdateTeamMemberStub
	fakeReturns := fake.updateTeamMemberReturns
	fake.recordInvocation("UpdateTeamMember", []interface{}{arg1, arg2})
	fake.updateTeamMemberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIBatchAPI) UpdateTeamMemberCallCount() int {
	fake.updateTeamMemberMutex.RLock()
	defer fake.updateTeamMemberMutex.RUnlock()
	return len(fake.updateTeamMemberArgsForCall)
}

func (fake *FakeIBatchAPI) UpdateTeamMemberCalls(stub func(string, *batch.UpdateTeamMemberRequest) (*batch.UpdateTeamMemberResponse, diag.Diagnostics)) {
	fake.updateTeamMemberMutex.Lock()
	defer fake.updateTeamMemberMutex.Unlock()
	fake.UpdateTeamMemberStub = stub
}

func (fake *FakeIBatchAPI) UpdateTeamMemberArgsForCall(i int) (string, *batch.UpdateTeamMemberRequest) {
	fake.updateTeamMemberMutex.RLock()
	defer fake.updateTeamMemberMutex.RUnlock()
	argsForCall := fake.updateTeamMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIBatchAPI) UpdateTeamMemberReturns(result1 *batch.UpdateTeamMemberResponse, result2 diag.Diagnostics) {
	fake.updateTeamMemberMutex.Lock()
	defer fake.updateTeamMemberMutex.Unlock()
	fake.UpdateTeamMemberStub = nil
	fake.updateTeamMemberReturns = struct {
		result1 *batch.UpdateTeamMemberResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) UpdateTeamMemberReturnsOnCall(i int, result1 *batch.UpdateTeamMemberResponse, result2 diag.Diagnostics) {
	fake.updateTeamMemberMutex.Lock()
	defer fake.updateTeamMemberMutex.Unlock()
	fake.UpdateTeamMemberStub = nil
	if fake.updateTeamMemberReturnsOnCall == nil {
		fake.updateTeamMemberReturnsOnCall = make(map[int]struct {
			result1 *batch.UpdateTeamMemberResponse
			result2 diag.Diagnostics
		})
	}
	fake.updateTeamMemberReturnsOnCall[i] = struct {
		result1 *batch.UpdateTeamMemberResponse
		result2 diag.Diagnostics
	}{result1, result2}
}

func (fake *FakeIBatchAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createCollectionMutex.RLock()
	defer fake.createCollectionMutex.RUnlock()
	fake.createTeamMemberMutex.RLock()
	defer fake.createTeamMemberMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.deleteTeamMemberMutex.RLock()
	defer fake.deleteTeamMemberMutex.RUnlock()
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	fake.getDataLakeMutex.RLock()
	defer fake.getDataLakeMutex.RUnlock()
	fake.getSchemaMutex.RLock()
	defer fake.getSchemaMutex.RUnlock()
	fake.getTeamMemberMutex.RLock()
	defer fake.getTeamMemberMutex.RUnlock()
	fake.updateCollectionMutex.RLock()
	defer fake.updateCollectionMutex.RUnlock()
	fake.updateTeamMemberMutex.RLock()
	defer fake.updateTeamMemberMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIBatchAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ batch.IBatchAPI = new(FakeIBatchAPI)
